<a name="13.1" />
# 13.1 虚拟化简介

近些年，虚拟化逐渐成为了热点话题，但它其实仍旧是将硬件资源抽象为一个虚拟层，这本身并不是什么新鲜事物。现在所有的操作系统中标配的虚拟内存就是一种虚拟化，单一物理硬盘划分为多个分区也是一种虚拟化。相比之下，最近热炒的虚拟化更多的是指虚拟整个物理机，不过这也不是什么新玩意，早在1960年代IBM就已经开始做相关的产品了。但直到最近，才真正充分发挥了虚拟化的威力，既增加了资源利用率，又提升了整体的管理能力。

虚拟化是以软件模拟运行平台（如操作系统）或在虚拟硬件上运行独立的应用程序。想你硬件通常与实际运行的物理硬件类似，部署在虚拟系统上的应用程序套件通常称为 **客户应用程序（guest）**，而被称为 **虚拟机管理程序（hypervisor）**的软件栈则可以使多个客户应用程序运行在同一个系统上。虚拟机管理程序可以为客户应用程序提供设备驱动程序，使其可以运行在虚拟环境中，进而提升 客户应用程序的运行性能。

>不同类型的虚拟化资源在其具体是线上有所不同。例如，看起来像是物理硬盘的资源，实际上只是某处服务器上的一个或一组文件；看起来像是有4个物理CPU可用，实际上可能只是几个CPU分时共享而已；看起来有1GB物理内存可用，实际上可能只是大容量物理内存的一部分。某些虚拟化管理程序甚至允许客户应用程序分配出的内存容量超过其分配限额。不过对于客户应用程序来说这无所谓，它仍旧只能看到其分配限额的内存（当然也有例外）。

虚拟化愈炒愈热，主要原因在于虚拟化可以更高效的利用已有的硬件资源。如果物理机上的CPU处于空闲状态（例如可能是在等待IO），那么就真的是只能闲置了。而对于那些运行了多个客户应用程序的虚拟环境来说，若某个客户应用程序的CPU处于空闲状态，则可以将CPU资源交给其他客户应用程序使用。当然，若是多个客户应用程序都特别"忙"，则反而会因频繁的上下文切换而降低执行性能。不过虚拟化的优势实在诱人，它大大提升了硬件资源的利用率，在环境问题日益严重的今天，合理利用资源才能更好的利用能源。

虚拟化可以划分为多种类型，划分的主要依据是其背后所代表的平台层级。这其中所涉及到一些常被混淆的技术概念，接下来内容中会对其做简单介绍。虚拟化本身很复杂，却可以简化开发和运维。

<a name="13.1.1" />
## 13.1.1 全虚拟化

**全虚拟化（full virtualization）**是指，虚拟机管理程序模拟出当前系统平台所能提供的所有关键功能，例如设备交互和内存映射。这样，作为客户应用程序的应用软件就可以不经修改直接部署上线。

对于那些硬件不能直接支持虚拟化的平台来说，可以通过捕获客户应用程序执行的特权指令来模拟沙箱环境供其使用。

若是有硬件支持（例如Intel VT或AMD-V技术可以是CPU同时运行在多个操作系统上），实现虚拟化就更加方便了。有了硬件的直接支持，虚拟化将更有效率，性能更好。最近，出了CPU之外，其他硬件出现了直接支持虚拟化的趋势，例如现在某些网卡就内建了对虚拟化的直接支持。

有了硬件的直接支持后，虚拟化性能大幅提升，因而全虚拟化的发展突飞猛进。

<a name="13.1.2" />
## 13.1.2 半虚拟化

**半虚拟化（paravirtualization）**是指客户应用程序在运行时需要知晓其运行在虚拟环境。典型场景是，客户应用程序在执行特权操作时，需要通过显式调用虚拟机管理程序的API接口来才能完成操作，即客户应用程序必须要与底层抽象层进行通信，因而就需要知道它自己是运行在虚拟环境中的。

半虚拟化牺牲了部分虚拟化的灵活性，因为在将客户应用程序（例如操作系统）部署到虚拟环境之前需要做相应的修改。相应的，半虚拟化可以舍弃那些不必要的抽象层，进而提升整个虚拟环境的运行性能，而且用户也不必关心底层虚拟机管理程序的具体实现。例如，早期的Xen是一个只支持半虚拟化的虚拟机管理程序，主要功能就是运行那些预先打包好的操作系统镜像，用户只需要将应用程序部署在这些打包好的操作系统镜像上即可。

硬件的直接支持使全虚拟化大踏步前进，相比之下，半虚拟化则已是明日黄花。

<a name="13.1.3" />
## 13.1.3 其他虚拟化术语

虚拟化领域还有很多专业术语，用于表述不同的含义，例如 **部分虚拟化（partial virtualization）**。在某些场景下，半虚拟化和部分虚拟化是同一个意思，此外，部分虚拟化还可以表示虚拟硬件的指定部分。例如，在Macintosh计算机上，部分虚拟化还用与描述像Rosetta这样的二进制转换工具（使用在PowerPC上编译的软件可以运行在Intel架构上。）。

部分虚拟化并不强求硬件支持，操作系统中的虚拟内存也可算作是部分虚拟化的一种。最近，**操作系统级虚拟化**颇受关注，典型场景就是将操作系统划分为可以同时运行的多个实例，看起来像是真的有多个操作系统一样。广为人知的Solaris Containers就是以这种技术实现的。

<a name="13.1.4" />
## 13.1.4 虚拟机管理程序

虚拟机管理程序负责创建虚拟环境的软件层（未必有硬件的直接支持），为客户应用程序提供一个理想的物理机的抽象层，捕获客户应用程序所有可能破坏抽象层的"危险操作"，将其转换为自身实现的具有相同功能的"安全操作"。

正如虚拟化有多种类型，虚拟机管理程序也有多种类型，这里只对托管型虚拟机管理程序和本地型虚拟机管理程序做相关介绍。

<a name="13.1.4.1" />
## 13.1.4.1 托管型虚拟机管理程序

托管型虚拟机管理程序一般是作为操作系统的一个标准进程来运行，捕获客户应用程序的"敏感操作"，替换为自身实现的"安全操作"，对于客户应用程序中以用户模式执行的操作，则可以作为虚拟机管理程序进程的一部分来直接执行，当然，也可以通过模拟或JIT解释的方式来运行"安全操作"。

托管型虚拟机管理程序的主要优势在于安装使用非常方便，虚拟机管理程序本身就是操作系统中的一个应用程序而已。通常来说，托管型虚拟机管理程序还不足以满足服务器端对性能的要求，不过没关系，这本身就不是托管型虚拟机管理程序的主要用途。

>本书的大部分内容都在是Macintosh电脑上完成的，而JRockit目前还不支持该平台。因此，作者就通过托管型虚拟机管理程序 VMware Fusion在Macintosh电脑上运行了一个Linux系统来操作JRockit。

VMware Player和Oracle VirtualBox就是简单的托管型虚拟机管理程序。

<a name="13.1.4.2" />
## 13.1.4.2 本地型虚拟机管理程序

本地型虚拟机管理程序无需操作系统的支持，可以直接安装在物理硬件上，硬件驱动由虚拟机管理程序提供，具体来说可以是独立的专用虚拟机（如Oracle虚拟机中基于VM或Xen的解决方案），或者是作为虚拟机管理程序本身的一部分来提供（例如VMware ESX）。

一般情况下，本地型虚拟机管理程序的执行性能远高于托管型虚拟机管理程序。Oracle VM和VMware ESX就是本地型虚拟机管理程序，虽然其实现原理不尽相同，但都可以之间安装在物理硬件上。

<a name="13.1.4.3" />
## 13.1.4.3 市面上其他虚拟机管理程序

得益于虚拟化市场的快速发展，现在有多款成熟的虚拟机管理程序可供选择。

**Xen**是一款开源的虚拟机管理程序，最初由Cambridge大学开发，并成立XenSource公司运营该产品，在2007年被Citrix公司收购。后来，Citrix公司发布了带有额外API的商业版本，而基于开源协议的Xen本身仍是免费的。

Xen因其开源属性而得到广泛应用，它不断发展，已经发展为本地型虚拟机管理程序，与Oracle VM类似。Oracle VM是Oracle公司出品的基于Linux系统的操作系统，其底层实现是Xen和本地型虚拟机管理程序。

最初，Xen是一个半虚拟化解决方案，也就是说，客户应用程序须需要配合虚拟机管理程序才能完成工作。例如，运行在半虚拟化的Xen的上Linux内核需要针对Xen专门编译一下才能使用。不过，Xen终究还是顺从了潮流，逐步向本地型虚拟机管理程序转变。

**VMware公司**是虚拟化领域的领导者之一，发布了多款虚拟化产品，本地型和托管型均有涉及，最终的明星产品包括VMware Workstation（在Macintosh上市VMware Fusion）、WMware ESX和VMware ESXi等，这些都是商业产品。VMware Workstation还有一款功能略有缩水的免费版，称为WMware Player，该版本不能创建和配置自定义的虚拟机，只能运行已有的虚拟机。此外，WMware还有一款托管型虚拟化平台，名为VMware Server，也是免费的。

微软公司自研的Hyper-V是针对Windows Server平台的虚拟化框架，应用广泛。使用Hyper-V需要有支持虚拟化的硬件。

KVM（Kernel-based Virtual Machine）是一个开源的虚拟机管理程序项目，以GPL协议发行，目前由Redhat主推。

Parallel公司在Macintosh、Windows和Linux平台上均开发了桌面版和服务器版的虚拟化软件。

此外，值得一提的是VirtualBox，这是一个独立的虚拟化包，其中包含了自有的虚拟机管理程序，其目标是支持桌面、服务器和嵌入式平台。VirtualBox最初是德国一家名为Innotek的公司研发的，后被Sun公司收购，不过现在已经归Oracle了。

<a name="13.1.5" />
## 13.1.5 虚拟化的优势

正如前面提到的，虚拟化的主要优势在于可以提升资源利用率。多个客户应用程序可以在同一台物理机器上各自使用所有的资源，当一个客户应用程序空闲时，另一个可能正在运行，因而可以降低服务器的空闲时间。

虚拟化的另一个优势就是"云计算"应用。虚拟化之后的客户应用程序可能需要挂起/恢复或迁移到其他物理机器，整个物理机器的暂停就可以被抽象为云计算的内部问题，而这些是可以通过各种管理框架来处理的。

>此外，还有一点就是，虚拟化更有利于"古董"的运行。IT部门常见的噩梦就是，某些应用程序是在"古董"硬件上开发的，这些硬件已经即将退役，而这些应用程序却不能向前兼容新的硬件平台。在将应用程序迁移到新硬件平台上时，要么完全重写一遍，要么就是用各种"大招"（例如COBOL转Java）来勉强趟过这潭浑水。这时，若是能虚拟一份"古董"硬件就可以使"古董"应用程序继续运行了，替换硬件的压力也就小得多了。

<a name="13.1.6" />
## 13.1.6 虚拟化的劣势

虚拟化的主要劣势在于，虚拟机管理程序在客户应用程序和硬件之间提供的抽象层会带来额外的性能损耗。虽然虚拟化提升了硬件资源的利用率，但带来的性能损耗也是需要注意的。

以Java应用程序为例，对于运行在本地的普通Java应用程序来说，JVM本身就是一种对硬件的抽象，而运行着JVM的操作系统则是对硬件的另一种抽象，而对于运行在虚拟环境的Java应用程序来说，而负责创建虚拟环境的虚拟机管理程序则是在操作系统下，为应用程序和其实际运行的本地代码之间提供了新的抽象层。

要将每一个抽象层尽量做得"锋利"并不难，难的是如何将各抽象层融合到一起。例如，通过硬件支持来实现虚拟机管理程序可以降低虚拟化的性能损耗，但为了虚拟化应用程序却仍不得不虚拟物理硬件，而这部分性能损耗就无法消除了。